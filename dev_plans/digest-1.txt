Directory structure:
â””â”€â”€ slimes/
    â”œâ”€â”€ CLAUDE.md
    â”œâ”€â”€ game-design.md
    â”œâ”€â”€ index.html
    â”œâ”€â”€ package.json
    â”œâ”€â”€ sumarize.md
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vite.config.ts
    â””â”€â”€ src/
        â”œâ”€â”€ main.ts
        â”œâ”€â”€ core/
        â”‚   â”œâ”€â”€ GameConfig.ts
        â”‚   â””â”€â”€ TurnManager.ts
        â”œâ”€â”€ entities/
        â”‚   â””â”€â”€ Unit.ts
        â”œâ”€â”€ scenes/
        â”‚   â””â”€â”€ GameScene.ts
        â””â”€â”€ systems/
            â””â”€â”€ MapSystem.ts

================================================
FILE: CLAUDE.md
================================================

- æ€»æ˜¯æŠŠå¯¹è¯å’Œéœ€æ±‚è¿˜æœ‰ä»»åŠ¡æ‰§è¡Œæƒ…å†µè®°å½•åˆ°é¡¹ç›®æ ¹ç›®å½•çš„ markdown æ–‡æ¡£é‡Œï¼ˆsummarize.mdï¼‰
- ä¼˜å…ˆåˆ’åˆ†ä»»åŠ¡ï¼Œæ¯æ¬¡åªå®Œæˆä¸€ä¸ªä»»åŠ¡



================================================
FILE: game-design.md
================================================
### **ã€Šå²è±å§†çš„é‡æœ›ã€‹æ ¸å¿ƒæ¸¸æˆæœºåˆ¶æå–æ–‡æ¡£**

#### **1. æ¸¸æˆæ ¸å¿ƒå¾ªç¯ (Core Gameplay Loop)**

è¿™æ˜¯ä¸€æ¬¾**å›åˆåˆ¶æˆ˜æ£‹ (Turn-Based Tactics)** æ¸¸æˆã€‚å…¶æ ¸å¿ƒå¾ªç¯å¦‚ä¸‹ï¼š

1.  **æˆ˜å‰å‡†å¤‡ (Pre-Battle Phase):**
    *   ç©å®¶ä»è‡ªå·±æ‹¥æœ‰çš„å²è±å§†ä¸­é€‰æ‹©ä¸€å®šæ•°é‡ï¼ˆæ ¹æ®å…³å¡é™åˆ¶ï¼‰çš„å•ä½å‡ºæˆ˜ã€‚
    *   å¯ä»¥æŸ¥çœ‹å…³å¡å†…çš„æ•Œäººé…ç½®ã€åœ°å½¢ç­‰ä¿¡æ¯æ¥åˆ¶å®šç­–ç•¥ã€‚
    *   å¯ä»¥é€šè¿‡â€œæºè¡Œâ€ç±»å²è±å§†ï¼ˆå¦‚Hermesï¼‰æºå¸¦ä¸Šä¸€åœºæˆ˜æ–—ä¸­å¤ºå–çš„æ•Œæ–¹å•ä½ç›´æ¥å‚æˆ˜ã€‚

2.  **æˆ˜æ–—é˜¶æ®µ (Battle Phase):**
    *   æ¸¸æˆåœ¨æ£‹ç›˜å¼åœ°å›¾ä¸Šè¿›è¡Œï¼Œæ•Œæˆ‘åŒæ–¹è½®æµè¡ŒåŠ¨ã€‚
    *   ç©å®¶å›åˆï¼šç©å®¶å¯ä»¥æ“ä½œè‡ªå·±æ‰€æœ‰çš„å•ä½ï¼ˆå²è±å§†å’Œå·²è¢«å¤ºå–çš„äººç±»ï¼‰è¿›è¡Œè¡ŒåŠ¨ï¼Œæ¯ä¸ªå•ä½ä¸€æ¬¡æœºä¼šã€‚è¡ŒåŠ¨é€‰é¡¹åŒ…æ‹¬ï¼š
        *   **ç§»åŠ¨ (Move):** åœ¨è“è‰²é«˜äº®åŒºåŸŸå†…ç§»åŠ¨ã€‚
        *   **æ”»å‡» (Attack):** å¯¹æ•Œäººé€ æˆä¼¤å®³ã€‚
        *   **å¤ºå– (Claim):** å²è±å§†çš„æ ¸å¿ƒèƒ½åŠ›ï¼Œé’»å…¥æ•Œäººèº«ä½“å¹¶æ§åˆ¶ä»–ä»¬ï¼Œæ˜¯æ¸¸æˆæœ€ç‹¬ç‰¹çš„æœºåˆ¶ã€‚
        *   **ç‰¹æ®Šèƒ½åŠ› (Ability):** ä½¿ç”¨å²è±å§†æˆ–ç‰¹å®šäººç±»å•ä½çš„ç‹¬æœ‰æŠ€èƒ½ï¼ˆå¦‚åŠ é€Ÿã€èåŒ–ã€æ²»ç–—ç­‰ï¼‰ã€‚
        *   **å¾…æœº (Wait):** ç»“æŸå½“å‰å•ä½çš„è¡ŒåŠ¨ã€‚
    *   æ•Œäººå›åˆï¼šæ•Œæ–¹AIæ§åˆ¶å…¶æ‰€æœ‰å•ä½è¿›è¡Œè¡ŒåŠ¨ã€‚

3.  **èƒœåˆ©/å¤±è´¥æ¡ä»¶ (Win/Loss Conditions):**
    *   **èƒœåˆ©æ¡ä»¶ï¼š** å¤ºå–æˆ–æ¶ˆç­æ‰€æœ‰æ•Œæ–¹å•ä½ã€‚
    *   **å¤±è´¥æ¡ä»¶ï¼š** å·±æ–¹æ‰€æœ‰å•ä½ï¼ˆåŒ…æ‹¬å²è±å§†å’Œè¢«å¤ºå–çš„å•ä½ï¼‰è¢«æ¶ˆç­ã€‚æ”»ç•¥ä¸­æåˆ°ï¼ŒæŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼ˆå¦‚è¢«å¥³ç‹å‡»è´¥ï¼‰ä¹Ÿå¯èƒ½ç›´æ¥åˆ¤è´Ÿã€‚
    *   æˆ˜æ–—å¤±è´¥æ²¡æœ‰æƒ©ç½šï¼Œç©å®¶å¯ä»¥éšæ—¶é‡æ–°æŒ‘æˆ˜ï¼Œè¿™é¼“åŠ±ç©å®¶ä¸æ–­å°è¯•å’Œä¼˜åŒ–ç­–ç•¥ã€‚

#### **2. å•ä½åŸºç¡€å±æ€§ (Unit Attributes)**

æ¯ä¸ªå•ä½ï¼ˆå²è±å§†ã€äººç±»ã€æ€ªç‰©ï¼‰éƒ½ç”±ä»¥ä¸‹æ ¸å¿ƒå±æ€§å®šä¹‰ï¼š

*   **HP (Health Points):** ç”Ÿå‘½å€¼ï¼Œå½’é›¶åˆ™å•ä½è¢«æ¶ˆç­ã€‚
*   **ATK (Attack):** ç‰©ç†æ”»å‡»åŠ›ï¼Œå†³å®šç‰©ç†æ”»å‡»é€ æˆçš„ä¼¤å®³ã€‚
*   **DEF (Defense):** ç‰©ç†é˜²å¾¡åŠ›ï¼Œå‡å…å—åˆ°çš„ç‰©ç†ä¼¤å®³ã€‚
*   **ç§»åŠ¨åŠ› (Move/Moving Force):** æ¯å›åˆå¯ä»¥ç§»åŠ¨çš„æ ¼å­æ•°ã€‚
*   **æ”»å‡»èŒƒå›´ (Attack Range):** èƒ½å¤Ÿå‘åŠ¨æ”»å‡»çš„è·ç¦»ã€‚åˆ†ä¸ºè¿‘æˆ˜ï¼ˆ1æ ¼ï¼‰å’Œè¿œç¨‹ï¼ˆ2æ ¼æˆ–ä»¥ä¸Šï¼‰ã€‚
*   **å…ƒç´ å±æ€§ (Elemental Affinity):** åˆ†ä¸º**æ°´ã€ç«ã€è‰**ä¸‰å¤§åŸºç¡€å±æ€§ï¼Œä»¥åŠç‰¹æ®Šçš„**å¤ªé˜³**å±æ€§ã€‚
*   **ç‰¹æ®Šèƒ½åŠ› (Special Ability):** å•ä½çš„ç‹¬æœ‰æŠ€èƒ½ï¼Œæ˜¯ç­–ç•¥çš„æ ¸å¿ƒã€‚
*   **å¯å¤ºå–ç‡ (Claimability %):** ä»…é™æ•Œæ–¹å•ä½ï¼Œè¡¨ç¤ºå²è±å§†æˆåŠŸå¤ºå–çš„æ¦‚ç‡ã€‚ä»100%åˆ°0%ç”šè‡³xï¼ˆä¸å¯å¤ºå–ï¼‰ä¸ç­‰ã€‚
*   **ç­‰çº§ (Level):** å•ä½çš„å¼ºåº¦ç­‰çº§ï¼Œå½±å“HPã€ATKã€DEFç­‰ã€‚
*   **ç§æ—/èŒä¸š (Type/Class):** å¦‚å‰‘å£«ã€å¼“ç®­æ‰‹ã€å²è±å§†ç­‰ã€‚
*   **æ€§åˆ« (Gender):** å½±å“æŸäº›ç‰¹æ®Šèƒ½åŠ›ï¼ˆå¦‚é­…æƒ‘ï¼‰ã€‚

#### **3. æ ¸å¿ƒæœºåˆ¶ï¼šå¤ºå– (Claim/Possession)**

è¿™æ˜¯æ¸¸æˆæœ€æ ¸å¿ƒã€æœ€ç‹¬ç‰¹çš„æœºåˆ¶ã€‚

*   **åŸºæœ¬åŸç†:** å²è±å§†å•ä½å¯ä»¥æ¶ˆè€—è‡ªå·±ï¼Œè¿›å…¥æ•Œæ–¹äººç±»å•ä½ä½“å†…å¹¶æ°¸ä¹…æ§åˆ¶è¯¥å•ä½ã€‚è¢«å¤ºå–çš„å•ä½å°†æˆä¸ºç©å®¶çš„æ°¸ä¹…æˆ˜åŠ›ï¼ˆåœ¨è¯¥åœºæˆ˜æ–—ä¸­ï¼‰ã€‚
*   **å¤ºå–æˆåŠŸç‡:**
    *   ä¸åŒæ•Œäººæœ‰ä¸åŒçš„åŸºç¡€â€œå¯å¤ºå–ç‡â€ï¼Œå¦‚å†œæ°‘ï¼ˆ100%ï¼‰ã€éª‘å£«ï¼ˆ20%ï¼‰ã€å¿è€…ï¼ˆ1%ï¼‰ã€é“ ç”²å…µï¼ˆ0%ï¼‰ã€‚
    *   **å²è±å§†èƒ½åŠ›ä¿®æ­£:**
        *   `Carrot` å²è±å§†å¤ºå–æŠ—æ€§å•ä½çš„æˆåŠŸç‡æ˜¯æ™®é€šå²è±å§†çš„ **5å€**ï¼ˆ20% -> 100%ï¼‰ã€‚
        *   `Rider` å²è±å§†çš„æˆåŠŸç‡æ˜¯æ™®é€šå²è±å§†çš„ **100å€**ï¼ˆ1% -> 100%ï¼‰ã€‚
        *   `Little Slime` çš„ **â€œSlowâ€** æŠ€èƒ½å¯ä»¥ä½¿ç›®æ ‡â€œå¯å¤ºå–ç‡â€**x5**ï¼ŒæŒç»­3å›åˆã€‚
        *   `Sticky` å²è±å§†çš„ **â€œStickyâ€** æŠ€èƒ½å¯ä»¥ä½¿ç›®æ ‡â€œå¯å¤ºå–ç‡â€å˜ä¸º **100%**ï¼ˆå¯¹0%å•ä½åˆ™å˜ä¸º1%ï¼‰ï¼ŒæŒç»­3å›åˆã€‚
    *   **æŠ€èƒ½å åŠ è§„åˆ™:** Slowå’ŒStickyæ•ˆæœ**äº’ç›¸è¦†ç›–**ï¼Œä¸èƒ½å åŠ ã€‚å…ˆç”¨Stickyå†ç”¨Slowï¼Œåˆ™Stickyæ•ˆæœæ¶ˆå¤±ã€‚
*   **å¤ºå–åçš„å±æ€§åŠ æˆ (Stat Boosts):**
    *   **å…ƒç´ åŒäº² (Elemental Affinity):** å¦‚æœå²è±å§†ä¸è¢«å¤ºå–å•ä½çš„å…ƒç´ å±æ€§ç›¸åŒï¼Œåˆ™è¯¥å•ä½è·å¾— **+25% ATK å’Œ +25% DEF** çš„åŠ æˆã€‚
    *   **æ€§åˆ«åŒäº² (Gender Affinity):** `Peavy` ç±»å²è±å§†å¤ºå–åŒæ€§åˆ«çš„å¥³æ€§å•ä½æ—¶ï¼Œé™¤äº†å…ƒç´ åŠ æˆå¤–ï¼Œè¿˜æœ‰é¢å¤–åŠ æˆï¼ˆæ”»ç•¥æè¿°ä¸ºå…±è®¡40%çš„æ”»é˜²æå‡ï¼Œæ„å‘³ç€æ€§åˆ«åŠ æˆçº¦ä¸º15%ï¼‰ã€‚
    *   **ç‰¹æ®Šå²è±å§†åŠ æˆ:** `Attack Slime`ã€`Guard Slime`ã€`Magic Slime` åœ¨å¤ºå–åŒå…ƒç´ å•ä½æ—¶ï¼Œæä¾›40%çš„å¯¹åº”å±æ€§åŠ æˆï¼ˆè€Œé25%ï¼‰ã€‚
*   **å¤ºå–åçš„çŠ¶æ€:**
    *   `Irregular` å²è±å§†å¤ºå–åï¼Œè¢«å¤ºå–çš„å•ä½å¯ä»¥**ç«‹å³è¡ŒåŠ¨ä¸€æ¬¡**ã€‚
    *   è¢«å¤ºå–åï¼ŒåŸå²è±å§†æ¶ˆå¤±ã€‚å¦‚æœè¢«å¤ºå–çš„å•ä½è¢«å‡»è´¥ï¼Œé™¤éæ˜¯â€œå¤æ´»ç³»â€å²è±å§†ï¼Œå¦åˆ™å•ä½å½»åº•æ¶ˆå¤±ã€‚
    *   æ•Œæ–¹çš„å¯„ç”Ÿå•ä½ï¼ˆå¦‚Asmodian, Hollow Slimeï¼‰ä¹Ÿå¯ä»¥å¤ºå–å•ä½ï¼Œå¹¶æä¾›å¼ºå¤§çš„å±æ€§åŠ æˆï¼ˆ30%-40%ï¼‰ã€‚å¦‚æœå®ƒä»¬å¤ºå–äº†ç©å®¶å·²å¤ºå–çš„å•ä½ï¼Œç©å®¶çš„å²è±å§†ä¼šè¢«**â€œå¼¹å‡ºâ€**å¹¶å­˜æ´»ä¸‹æ¥ã€‚

#### **4. æˆ˜æ–—ç³»ç»Ÿ (Combat System)**

*   **å…ƒç´ å…‹åˆ¶ (Elemental System):**
    *   **æ°´ > ç« > è‰ > æ°´** å¾ªç¯å…‹åˆ¶ã€‚
    *   **å¤ªé˜³** å±æ€§å…‹åˆ¶æ‰€æœ‰å…¶ä»–å±æ€§ã€‚
    *   **ä¼¤å®³è®¡ç®—:** æ”»å‡»å…‹åˆ¶å±æ€§ï¼Œä¼¤å®³ **+50%**ã€‚æ”»å‡»è¢«å…‹åˆ¶å±æ€§ï¼Œä¼¤å®³ **-50%**ã€‚
*   **åœ°å½¢ä¸é«˜ä½å·® (Elevation):**
    *   **é«˜æ‰“ä½:** æ”»å‡»ä¼¤å®³ **+10%** æˆ–æ›´å¤šï¼ˆå–å†³äºé«˜åº¦å·®ï¼‰ã€‚
    *   **ä½æ‰“é«˜:** æ”»å‡»ä¼¤å®³å¤§å¹…é™ä½ã€‚
    *   é­”æ³•æ”»å‡»æ— è§†é«˜ä½å·®é™åˆ¶ã€‚
*   **æ”»å‡»ç±»å‹:**
    *   **è¿‘æˆ˜ (Direct):** æ”»å‡»èŒƒå›´1ï¼Œä¼šå—åˆ°åå‡»ã€‚
    *   **è¿œç¨‹ (Ranged):** æ”»å‡»èŒƒå›´2æˆ–ä»¥ä¸Šï¼Œåœ¨è‡ªèº«æ”»å‡»èŒƒå›´å¤–æ”»å‡»è¿‘æˆ˜å•ä½æ—¶ï¼Œ**ä¸ä¼šå—åˆ°åå‡»**ã€‚
    *   **é­”æ³• (Magic):** é€šå¸¸æœ‰èŒƒå›´æ•ˆæœï¼ˆå¦‚åå­—å½¢5æ ¼ï¼‰ï¼Œæ— è§†é«˜ä½å·®ï¼Œä¸è§¦å‘åå‡»ã€‚
*   **åå‡» (Counterstrike):**
    *   è¿‘æˆ˜å•ä½è¢«æ”»å‡»åä¼šè‡ªåŠ¨åå‡»ï¼Œä¼¤å®³çº¦ä¸ºæ­£å¸¸æ”»å‡»çš„ **50%**ã€‚
*   **ä¼¤å®³æµ®åŠ¨ (Damage Variance):**
    *   æ‰€æœ‰ä¼¤å®³éƒ½æœ‰ä¸€ä¸ª **Â±25%** çš„éšæœºæµ®åŠ¨åŒºé—´ï¼Œå¢åŠ äº†æˆ˜æ–—çš„ä¸ç¡®å®šæ€§ã€‚
*   **æ¢å¤æœºåˆ¶ (Recovery):**
    *   åœ°å›¾ä¸Šçš„**æ¢å¤æ——å¸œ (Recovery Flag)** å¯ä»¥è®©ç«™åœ¨ä¸Šé¢çš„å•ä½æ¯å›åˆæ¢å¤ **20% - 40%** çš„æœ€å¤§HPï¼ˆä»¥4%ä¸ºæ­¥é•¿éšæœºï¼‰ã€‚
    *   é­”æ³•å’Œç‚®å…µå•ä½éœ€è¦ç«™åœ¨æ——å¸œä¸Šæ‰èƒ½è¡¥å……æœ‰é™çš„å¼¹è¯/é­”æ³•æ¬¡æ•°ã€‚

#### **5. çŠ¶æ€æ•ˆæœä¸ç‰¹æ®Šèƒ½åŠ› (Status Effects & Abilities)**

è¿™æ˜¯ç­–ç•¥æ·±åº¦çš„å…³é”®ã€‚

| æ•ˆæœ/èƒ½åŠ› | æ¥æºå²è±å§†/å•ä½ | æ•ˆæœæè¿° | æŒç»­æ—¶é—´ |
| :--- | :--- | :--- | :--- |
| **Slow (å‡é€Ÿ)** | Little Slime | ç›®æ ‡ç§»åŠ¨åŠ›é™ä¸º1ï¼Œå¯å¤ºå–ç‡x5ã€‚ | 3å›åˆ |
| **Sticky (ç²˜æ»)** | Sticky | ç›®æ ‡æ— æ³•ç§»åŠ¨ï¼Œå¯å¤ºå–ç‡å˜ä¸º100%ï¼ˆ0%å˜ä¸º1%ï¼‰ã€‚ | 3å›åˆ |
| **Melt (èåŒ–)** | Melty, Heavy Peavy | ç§»é™¤ç›®æ ‡è£…å¤‡ï¼Œå¤§å¹…é™ä½é˜²å¾¡ï¼Œå˜ä¸º100%å¯å¤ºå–ã€‚ | 3å›åˆ |
| **Super Melt (è¶…çº§èåŒ–)**| Super Melty | åŒä¸Šï¼Œä½†èƒ½å¯¹é“ ç”²å…µç­‰æŠ—æ€§å•ä½ç”Ÿæ•ˆã€‚ | 5å›åˆ |
| **Charm (é­…æƒ‘)** | Meltedå•ä½ | ä½¿å¼‚æ€§æ•Œäººå›å˜ï¼Œæ”»å‡»å…¶å‹å†›ã€‚ | 3å›åˆ |
| **Bribe (è´¿èµ‚)** | Merchant | ä½¿ä»»æ„æ•Œäººå›å˜ã€‚ | 3å›åˆ |
| **Honeytrap (ç”œèœœé™·é˜±)** | Girl | ä½¿ç”·æ€§æ•Œäººå›å˜ã€‚ | 3å›åˆ |
| **Order (å‘½ä»¤)** | Valoi King | ä½¿ä»»æ„æ•Œäººå›å˜ã€‚ | 1å›åˆ |
| **Invisible (éšèº«)** | Invisible | è‡ªèº«éšå½¢ï¼Œä¸ä¼šæˆä¸ºå•ä½“æ”»å‡»ç›®æ ‡ï¼Œæ”»å‡»ä¸è¢«åå‡»ã€‚ | 3å›åˆ |
| **Teleport (ä¼ é€)** | Teleport, Neo | ä¼ é€ä»»æ„å•ä½ï¼ˆé™¤è‡ªèº«ï¼‰åˆ°åœ°å›¾ä»»æ„ç©ºæ ¼ã€‚ | - |
| **Warp (è·ƒè¿)** | Warp Slime | ä¼ é€è‡ªèº«åˆ°åœ°å›¾ä»»æ„ç©ºæ ¼ã€‚ | - |
| **ATK+/DEF+/MP+** | Attacker, Defender, Wiz | ä¸ºå‹æ–¹å•ä½æä¾›20%çš„æ”»å‡»/é˜²å¾¡/é­”æ³•ä¼¤å®³å¢ç›Šã€‚ | æ•´åœºæˆ˜æ–— |
| **Carryover (æºå¸¦)** | Hermes, Super Hermes| æˆ˜æ–—ç»“æŸåï¼Œè‹¥è¢«å¤ºå–çš„å•ä½å­˜æ´»ï¼Œå¯å¸¦å…¥ä¸‹ä¸€åœºæˆ˜æ–—ã€‚ | 1-4åœºæˆ˜æ–—|
| **Revive (å¤æ´»)** | Guts, Phoenix | è¢«å¤ºå–çš„å•ä½è¢«å‡»è´¥åï¼Œå²è±å§†ä¼šå¤æ´»ï¼Œå¯ä»¥å†æ¬¡å¤ºå–ã€‚ | 1-2æ¬¡æˆ–æ— é™|
| **Split (åˆ†è£‚)** | Divide, Goddess' Hand| è¢«æ”»å‡»ååˆ†è£‚æˆ2ä¸ªæˆ–4ä¸ªå•ä½ï¼ŒHPå¹³åˆ†ã€‚ | - |
| **Steal (å·çªƒ)** | Isabella | æ•ˆæœåŒSuper Meltã€‚ | 3å›åˆ |

#### **6. æ¸¸æˆè¿›ç¨‹ä¸å…ƒæ¸¸æˆ (Progression & Meta-Game)**

*   **å²è±å§†è·å–:** æˆ˜æ–—èƒœåˆ©åï¼Œæœ‰ä¸€å®šæ¦‚ç‡å¸å¼•é‡ç”Ÿå²è±å§†åŠ å…¥é˜Ÿä¼ã€‚ç‰¹å®šå…³å¡é¦–æ¬¡é€šå…³ä¼š100%è·å¾—ç‰¹å®šå²è±å§†ã€‚
*   **ç»éªŒä¸å‡çº§ (Experience & Leveling):**
    *   å‚ä¸æˆ˜æ–—å¹¶å­˜æ´»çš„å²è±å§†ä¼šè·å¾—ç»éªŒå€¼ã€‚
    *   ç»éªŒå€¼è·å–é‡å—å…³å¡éš¾åº¦å½±å“ï¼ˆå›°éš¾1.5å€ï¼Œç®€å•0.5å€ï¼‰ã€‚
    *   å‡çº§ä¼šæå‡åŸºç¡€å±æ€§ï¼ˆå¦‚+5 HPï¼‰ã€‚
    *   è¾¾åˆ°ç‰¹å®šç­‰çº§ï¼ˆæˆç†ŸæœŸï¼‰åï¼Œå²è±å§†ä¼šè·å¾—**ç­‰çº§å¥–åŠ± (Level Up Bonus)**ï¼Œé€šå¸¸æ˜¯å¼ºåŒ–å…¶ç‰¹æ®Šèƒ½åŠ›ï¼ˆå¦‚å¢åŠ ä½¿ç”¨æ¬¡æ•°ã€æå‡ç§»åŠ¨åŠ›ç­‰ï¼‰ã€‚ç¨€æœ‰åº¦è¶Šé«˜çš„å²è±å§†ï¼Œæˆç†Ÿè¶Šæ™šã€‚
*   **å…³å¡ç»“æ„:**
    *   æ¸¸æˆåˆ†ä¸ºå¤šä¸ªå¤§åŒºåŸŸï¼ˆBaleares Kingdom, Witch Forestç­‰ï¼‰ã€‚
    *   æ¯ä¸ªåŒºåŸŸåŒ…å«å¤šä¸ªä¸»çº¿å…³å¡ã€‚
    *   é€šå…³ä¸€ä¸ªå…³å¡ä¼šè§£é”ä¸‹ä¸€ä¸ªã€‚
    *   æ¯ä¸ªå…³å¡éƒ½æœ‰**ç®€å• (Easy)ã€æ™®é€š (Normal)ã€å›°éš¾ (Hard)** ä¸‰ç§éš¾åº¦ã€‚
    *   é€šå…³ä»»ä¸€éš¾åº¦çš„å…³å¡åï¼Œä¼šè§£é”è¯¥åœ°å›¾çš„**æŒ‘æˆ˜å…³å¡ (Challenge Levels)**ï¼Œå…±5çº§ï¼Œéš¾åº¦æé«˜ï¼Œæ˜¯è·å–ç¨€æœ‰å²è±å§†çš„ä¸»è¦é€”å¾„ã€‚

#### **7. AI è¡Œä¸ºæ¨¡å¼ (AI Behavior Patterns)**

æ”»ç•¥ä¸­æ­ç¤ºäº†å¤§é‡AIçš„è¡Œä¸ºé€»è¾‘ï¼Œè¿™å¯¹äºå¤åˆ»æ¸¸æˆè‡³å…³é‡è¦ã€‚

*   **ç›®æ ‡é€‰æ‹©ä¼˜å…ˆçº§:**
    1.  **é‡‘å±å²è±å§†ä¼˜å…ˆ (Metal Slime Priority):** å¦‚æœ`Metal Slime`åœ¨æ”»å‡»èŒƒå›´å†…ï¼Œæ•Œäººå‡ ä¹æ€»ä¼šæ— è§†ä¸€åˆ‡å…¶ä»–å› ç´ ï¼ˆå¦‚é«˜ä½å·®ã€å…ƒç´ å…‹åˆ¶ï¼‰ä¼˜å…ˆæ”»å‡»å®ƒã€‚
    2.  **é«˜ä½å·®ä¼˜å…ˆ (Elevation Priority):** åœ¨æ²¡æœ‰é‡‘å±å²è±å§†çš„æƒ…å†µä¸‹ï¼Œæ•Œäººå€¾å‘äºæ”»å‡»èƒ½è·å¾—æœ€å¤§é«˜åº¦ä¼˜åŠ¿çš„ç›®æ ‡ï¼ˆå³æ”»å‡»å¤„åœ¨ä½å¤„çš„å•ä½ï¼‰ã€‚
    3.  **å¤šç›®æ ‡ä¼˜å…ˆ (Multi-Target Priority):** æ‹¥æœ‰èŒƒå›´æ”»å‡»çš„å•ä½ï¼ˆç‚®å…µã€æ³•å¸ˆï¼‰ä¼šä¼˜å…ˆé€‰æ‹©èƒ½åŒæ—¶å‡»ä¸­æœ€å¤šå•ä½çš„ä½ç½®ï¼Œæ­¤æ—¶å¯èƒ½å¿½ç•¥é«˜ä½å·®ã€‚
    4.  **é¿å…åå‡»ä¼˜å…ˆ (Avoid Counterstrike Priority):** è¿œç¨‹å•ä½ä¼šä¼˜å…ˆæ”»å‡»æ— æ³•åå‡»çš„ç›®æ ‡ã€‚
    5.  **æœ€è¿‘/æœ€è¿œç›®æ ‡ (Distance Priority):** åœ¨å…¶ä»–æ¡ä»¶ç›¸åŒçš„æƒ…å†µä¸‹ï¼ŒæŸäº›AIï¼ˆå¦‚è´¤è€…ï¼‰å€¾å‘äºæ”»å‡»æ›´è¿œçš„ç›®æ ‡ã€‚
*   **é˜µåœ°è¡Œä¸º (Positional Behavior):**
    *   å æ®é«˜åœ°ï¼ˆå¦‚å±‹é¡¶ã€æ‚¬å´–ï¼‰çš„æ•Œäººé€šå¸¸**ä¸ä¼šä¸»åŠ¨æ”¾å¼ƒ**å…¶ä½ç½®ä¼˜åŠ¿ã€‚
    *   **è§¦å‘æ¡ä»¶:** å¦‚æœç©å®¶ä»å…¶æ”»å‡»èŒƒå›´å¤–æ”»å‡»äº†è¿™äº›é«˜åœ°ä¸Šçš„æ•Œäººï¼Œå®ƒä»¬å°±ä¼šæ”¾å¼ƒé˜µåœ°ï¼Œä¸»åŠ¨å†²ä¸‹æ¥æ”»å‡»ç©å®¶ã€‚
*   **ç‰¹æ®Šå•ä½è¡Œä¸º:**
    *   **å¯„ç”Ÿå•ä½ (Asmodians):** ä¼šä¼˜å…ˆå¤ºå–èŒƒå›´å†…æœ€å¼ºå¤§çš„å¯å¤ºå–å•ä½ã€‚åœ¨é™„è¿‘æœ‰å¯å¤ºå–ç›®æ ‡æ—¶ï¼Œé€šå¸¸ä¸ä¼šä¸»åŠ¨æ”»å‡»ç©å®¶çš„å²è±å§†ã€‚
    *   **æ²»ç–—å•ä½ (Healers):** ä¼šä¼˜å…ˆæ²»ç–—HPç™¾åˆ†æ¯”æœ€ä½çš„å‹å†›ã€‚
    *   **è´¤è€… (Sages):** ç»å¯¹ä¸ä¼šæ”»å‡»è¢«`Invalidation`å²è±å§†å¤ºå–çš„å•ä½ã€‚

---

### **æ€»ç»“**

ã€Šå²è±å§†çš„é‡æœ›ã€‹çš„æ ¸å¿ƒé­…åŠ›åœ¨äºå…¶ç‹¬ç‰¹çš„**â€œå¤ºå–â€æœºåˆ¶**ä¸**é«˜ç­–ç•¥æ·±åº¦**çš„ç»“åˆã€‚å®ƒä¸æ˜¯ä¸€ä¸ªå•çº¯æ¯”æ‹¼æ•°å€¼çš„æ¸¸æˆï¼Œè€Œæ˜¯é¼“åŠ±ç©å®¶åˆ©ç”¨å„ç§å²è±å§†çš„ç‹¬ç‰¹èƒ½åŠ›ï¼Œé€šè¿‡**ä¿¡æ¯å·®ã€æˆ˜æœ¯æ¬ºéª—å’Œèµ„æºäº¤æ¢**æ¥æˆ˜èƒœè¿œæ¯”è‡ªå·±å¼ºå¤§çš„æ•Œäººã€‚

æä¾›ç»™AIåˆ¶ä½œæ¸¸æˆæ—¶ï¼Œåº”é‡ç‚¹å¼ºè°ƒä»¥ä¸‹å‡ ç‚¹ï¼š

1.  **éå¯¹ç§°å¯¹æŠ—:** ç©å®¶æ–¹ï¼ˆå²è±å§†ï¼‰æå…¶è„†å¼±ï¼Œä½†æ‹¥æœ‰æ”¹å˜æ¸¸æˆè§„åˆ™çš„å¼ºå¤§èƒ½åŠ›ï¼ˆå¤ºå–ã€èåŒ–ã€ä¼ é€ç­‰ï¼‰ã€‚æ•Œäººæ–¹ï¼ˆäººç±»ï¼‰æ•°å€¼å¼ºå¤§ï¼Œä½†è¡Œä¸ºæ¨¡å¼å›ºå®šï¼Œå®¹æ˜“è¢«åˆ©ç”¨ã€‚
2.  **ç­–ç•¥å¤šæ ·æ€§:** å¿…é¡»å®ç°æ”»ç•¥ä¸­æåˆ°çš„æ‰€æœ‰å²è±å§†å’Œæ•Œäººçš„ç‰¹æ®Šèƒ½åŠ›ï¼Œå¹¶ç¡®ä¿å®ƒä»¬ä¹‹é—´çš„äº¤äº’ï¼ˆå¦‚Slow vs Stickyï¼‰ç¬¦åˆè§„åˆ™ã€‚è¿™æ˜¯æ¸¸æˆç­–ç•¥æ·±åº¦çš„åŸºçŸ³ã€‚
3.  **æ™ºèƒ½ä½†å¯é¢„æµ‹çš„AI:** AIéœ€è¦éµå¾ªä¸Šè¿°çš„è¡Œä¸ºæ¨¡å¼ï¼ˆé«˜ä½å·®ã€é‡‘å±å²è±å§†ä¼˜å…ˆç­‰ï¼‰ï¼Œè¿™ä½¿å¾—ç©å®¶å¯ä»¥é€šè¿‡ç­–ç•¥â€œæ“çºµâ€AIçš„è¡ŒåŠ¨ï¼Œè·å¾—æˆå°±æ„Ÿã€‚
4.  **å…³å¡è®¾è®¡çš„æ ¸å¿ƒ:** å…³å¡è®¾è®¡åº”å›´ç»•â€œå¤ºå–â€å±•å¼€ï¼Œé€šè¿‡æ•Œäººé…ç½®ã€åœ°å½¢å’Œæ——å¸œä½ç½®ï¼Œå¼•å¯¼æˆ–é™åˆ¶ç©å®¶çš„å¤ºå–ç­–ç•¥ï¼Œåˆ›é€ å‡ºå¤šæ ·çš„è§£æ³•ã€‚

è¿™ä»½æ–‡æ¡£å·²ç»è¦†ç›–äº†åˆ¶ä½œè¿™æ¬¾æ¸¸æˆæ‰€éœ€çš„æ‰€æœ‰æ ¸å¿ƒæœºåˆ¶å’Œè§„åˆ™ã€‚ç¥ä½ ï¼ˆå’Œä½ çš„AIï¼‰åˆ¶ä½œé¡ºåˆ©ï¼



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å²è±å§†çš„é‡æœ›</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #game-container {
            border: 2px solid #333;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script type="module" src="/src/main.ts"></script>
</body>
</html>


================================================
FILE: package.json
================================================
{
  "name": "slimes",
  "version": "1.0.0",
  "description": "å²è±å§†çš„é‡æœ› - JavaScriptå¤ç°ç‰ˆ",
  "main": "index.js",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["game", "phaser", "typescript", "slime"],
  "author": "",
  "license": "ISC",
  "type": "module",
  "devDependencies": {
    "@types/node": "^24.0.14",
    "phaser": "^3.90.0",
    "typescript": "^5.8.3",
    "vite": "^7.0.4"
  }
}


================================================
FILE: sumarize.md
================================================
# å²è±å§†çš„é‡æœ› - JavaScriptå¤ç°é¡¹ç›®è¿›å±•è®°å½•

## é¡¹ç›®æ¦‚è¿°
ä½¿ç”¨JavaScript/TypeScript + Phaser 3å¤ç°ç»å…¸ç­–ç•¥æ¸¸æˆã€Šå²è±å§†çš„é‡æœ›ã€‹(Ambition of the Slimes)

## æŠ€æœ¯æ ˆ
- **æ¸¸æˆå¼•æ“**: Phaser 3.90.0
- **å¼€å‘è¯­è¨€**: TypeScript 5.8.3
- **æ„å»ºå·¥å…·**: Vite 7.0.4
- **è¿è¡Œç¯å¢ƒ**: Webæµè§ˆå™¨

## å·²å®Œæˆä»»åŠ¡ âœ…

### 1. é¡¹ç›®åŸºç¡€æ¶æ„æ­å»º
- âœ… é¡¹ç›®ç»“æ„è®¾è®¡ä¸åˆ›å»º
- âœ… å¼€å‘ç¯å¢ƒé…ç½® (TypeScript + Vite)
- âœ… åŸºç¡€é…ç½®æ–‡ä»¶åˆ›å»º (tsconfig.json, vite.config.ts)
- âœ… å…¥å£æ–‡ä»¶å’Œä¸»æ¸¸æˆé…ç½®å®Œæˆ

### 2. æ ¸å¿ƒç³»ç»Ÿå®ç°
- âœ… **åœ°å›¾ç³»ç»Ÿ**: 20x15ç½‘æ ¼åœ°å›¾ï¼Œæ”¯æŒåœ°å½¢æ¸²æŸ“å’Œç‚¹å‡»äº¤äº’
- âœ… **å•ä½ç³»ç»Ÿ**: å²è±å§†å’Œæ•Œäººçš„åŸºç¡€æ•°æ®ç»“æ„
- âœ… **å›åˆåˆ¶ç³»ç»Ÿ**: TurnManagerå®ç°å®Œæ•´çš„å›åˆå¾ªç¯
- âœ… **æ¸²æŸ“ç³»ç»Ÿ**: åŸºäºPhaserçš„æ¸¸æˆåœºæ™¯å’ŒUIæ¸²æŸ“

### 3. åŸºç¡€æ¸¸æˆåŠŸèƒ½
- âœ… ç½‘æ ¼åœ°å›¾æ˜¾ç¤ºå’Œé«˜äº®ç³»ç»Ÿ
- âœ… å•ä½ç§»åŠ¨å’Œæ”»å‡»æœºåˆ¶
- âœ… å›åˆåˆ‡æ¢å’ŒUIæ˜¾ç¤º
- âœ… é€‰æ‹©å’Œå–æ¶ˆé€‰æ‹©å•ä½

### 4. Bugä¿®å¤
- âœ… ä¿®å¤äº†`getCurrentTurn`æ–¹æ³•ä¸å­˜åœ¨çš„TypeError

## å½“å‰é¡¹ç›®ç»“æ„
```
src/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ GameConfig.ts     # æ¸¸æˆå…¨å±€é…ç½®
â”‚   â””â”€â”€ TurnManager.ts    # å›åˆç®¡ç†ç³»ç»Ÿ
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ Unit.ts          # å•ä½åŸºç¡€ç±»
â”œâ”€â”€ systems/
â”‚   â””â”€â”€ MapSystem.ts     # åœ°å›¾ç³»ç»Ÿ
â”œâ”€â”€ scenes/
â”‚   â””â”€â”€ GameScene.ts     # ä¸»æ¸¸æˆåœºæ™¯
â”œâ”€â”€ ui/                  # UIç»„ä»¶ (å¾…å®ç°)
â”œâ”€â”€ data/                # æ¸¸æˆæ•°æ® (å¾…å®ç°)
â””â”€â”€ utils/               # å·¥å…·å‡½æ•° (å¾…å®ç°)
```

## å¾…å®Œæˆä»»åŠ¡ ğŸ“‹

### æ ¸å¿ƒæœºåˆ¶å®Œå–„ (ä¼˜å…ˆçº§ï¼šé«˜)
- [ ] **å æ®ç³»ç»Ÿ**: å®ç°å²è±å§†å æ®æ•Œäººçš„æ ¸å¿ƒæœºåˆ¶
- [ ] **å…ƒç´ å…‹åˆ¶**: å®ç°æ°´â†’ç«â†’è‰â†’æ°´çš„å…‹åˆ¶å…³ç³»
- [ ] **æˆ˜æ–—è®¡ç®—**: å®Œå–„ä¼¤å®³è®¡ç®—å…¬å¼ï¼ŒåŒ…å«å…ƒç´ å…‹åˆ¶å’Œé«˜ä½å·®

### æ¸¸æˆå†…å®¹æ‰©å±• (ä¼˜å…ˆçº§ï¼šä¸­)
- [ ] **å²è±å§†ç‰¹æ®Šèƒ½åŠ›**: å®ç°å„ç§å²è±å§†çš„ç‹¬ç‰¹æŠ€èƒ½
- [ ] **çŠ¶æ€æ•ˆæœç³»ç»Ÿ**: å®ç°Meltã€Stickyã€Slowç­‰çŠ¶æ€æ•ˆæœ
- [ ] **æ•Œäººæ•°æ®é…ç½®**: å®Œå–„æ•Œäººå±æ€§å’Œå æ®ç‡ç³»ç»Ÿ
- [ ] **å…ƒç´ ç³»ç»Ÿ**: å®Œå–„å…ƒç´ ç±»å‹å’Œå…‹åˆ¶å…³ç³»

### æ¸¸æˆä½“éªŒä¼˜åŒ– (ä¼˜å…ˆçº§ï¼šä½)
- [ ] **æˆ˜æ–—é¢„æµ‹UI**: æ˜¾ç¤ºæ”»å‡»/å æ®çš„é¢„æµ‹ç»“æœ
- [ ] **å•ä½ä¿¡æ¯æ˜¾ç¤º**: è¯¦ç»†çš„å•ä½å±æ€§å’ŒçŠ¶æ€å±•ç¤º
- [ ] **åœ°å›¾å¤šæ ·æ€§**: ä¸åŒåœ°å½¢å’Œéšœç¢ç‰©
- [ ] **å­˜æ¡£ç³»ç»Ÿ**: æ¸¸æˆè¿›åº¦ä¿å­˜å’Œè¯»å–

## ä¸‹ä¸€æ­¥é‡ç‚¹
1. **å æ®ç³»ç»Ÿ**: å®ç°å²è±å§†ç§»åŠ¨åˆ°æ•Œäººæ—è¾¹å¹¶å°è¯•å æ®çš„æ ¸å¿ƒç©æ³•
2. **å…ƒç´ å…‹åˆ¶**: åœ¨ä¼¤å®³è®¡ç®—ä¸­è€ƒè™‘å…ƒç´ ç›¸å…‹å…³ç³»
3. **ç‰¹æ®Šèƒ½åŠ›**: å¼€å§‹å®ç°ä¸€äº›ç®€å•çš„å²è±å§†èƒ½åŠ›ï¼Œå¦‚Little Slimeçš„Slow

## å·²çŸ¥é—®é¢˜
- å½“å‰åªæœ‰åŸºç¡€ç§»åŠ¨å’Œæ”»å‡»ï¼Œç¼ºå°‘å æ®æœºåˆ¶
- å…ƒç´ å…‹åˆ¶å’Œé«˜ä½å·®ç³»ç»Ÿå°šæœªå®ç°
- ç¼ºå°‘çŠ¶æ€æ•ˆæœå’Œç‰¹æ®Šèƒ½åŠ›

## è¿è¡Œæ–¹å¼
```bash
npm run dev    # å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run build  # æ„å»ºç”Ÿäº§ç‰ˆæœ¬
```

---
*æœ€åæ›´æ–°ï¼š2025å¹´7æœˆ15æ—¥*


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["phaser"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: vite.config.ts
================================================
import { defineConfig } from 'vite'

export default defineConfig({
  root: '.',
  build: {
    outDir: 'dist',
    emptyOutDir: true,
    rollupOptions: {
      input: {
        main: 'index.html'
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
})


================================================
FILE: src/main.ts
================================================
import Phaser from 'phaser';
import { GameScene } from './scenes/GameScene';

const config: Phaser.Types.Core.GameConfig = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: 'game-container',
  backgroundColor: '#2c3e50',
  scene: [GameScene],
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false
    }
  }
};

new Phaser.Game(config);


================================================
FILE: src/core/GameConfig.ts
================================================
export const GAME_CONFIG = {
  GRID_SIZE: 32,
  MAP_WIDTH: 20,
  MAP_HEIGHT: 15,
  COLORS: {
    GRID: 0x34495e,
    GRID_BORDER: 0x2c3e50,
    SELECTED: 0x3498db,
    HOVER: 0x2980b9,
    MOVE_RANGE: 0x2ecc71,
    ATTACK_RANGE: 0xe74c3c,
    CLAIM_RANGE: 0xff00ff
  }
} as const;

export const ELEMENTS = {
  FIRE: 'fire',
  WATER: 'water',
  EARTH: 'earth',
  WIND: 'wind',
  LIGHT: 'light',
  DARK: 'dark'
} as const;

export type Element = typeof ELEMENTS[keyof typeof ELEMENTS];


================================================
FILE: src/core/TurnManager.ts
================================================
export enum TurnPhase {
  PLAYER_TURN = 'player_turn',
  ENEMY_TURN = 'enemy_turn',
  ANIMATION = 'animation',
  GAME_OVER = 'game_over'
}

interface TurnAction {
  type: 'move' | 'attack' | 'wait';
  unitId: string;
  targetX?: number;
  targetY?: number;
  targetUnitId?: string;
}

export class TurnManager {
  private currentPhase: TurnPhase = TurnPhase.PLAYER_TURN;
  private turnCount: number = 1;

  constructor(
    private playerUnits: Unit[],
    private enemyUnits: Unit[]
  ) {
    this.startNewRound();
  }

  startNewRound(): void {
    this.turnCount++;
    this.currentPhase = TurnPhase.PLAYER_TURN;
    
    // Reset all units' action state
    this.playerUnits.forEach(u => {
      u.hasActed = false;
      u.hasMovedThisTurn = false;
    });
    this.enemyUnits.forEach(u => {
      u.hasActed = false;
      u.hasMovedThisTurn = false;
    });
    
    console.log(`--- Round ${this.turnCount} ---`);
  }

  endPlayerTurn(): void {
    this.currentPhase = TurnPhase.ENEMY_TURN;
    console.log("Enemy turn starts.");
    // In the future, enemy AI logic will go here.
    // For now, it ends immediately.
    this.endEnemyTurn();
  }

  endEnemyTurn(): void {
    this.currentPhase = TurnPhase.PLAYER_TURN;
    console.log("Player turn starts.");
    this.startNewRound();
  }

  getCurrentPhase(): TurnPhase {
    return this.currentPhase;
  }

  checkGameOver(): { isOver: boolean; winner: 'player' | 'enemy' | null } {
    const alivePlayerUnits = this.playerUnits.filter(u => !u.isDead());
    const aliveEnemyUnits = this.enemyUnits.filter(u => !u.isDead());
    
    if (alivePlayerUnits.length === 0) {
      this.currentPhase = TurnPhase.GAME_OVER;
      return { isOver: true, winner: 'enemy' };
    }
    
    if (aliveEnemyUnits.length === 0) {
      this.currentPhase = TurnPhase.GAME_OVER;
      return { isOver: true, winner: 'player' };
    }
    
    return { isOver: false, winner: null };
  }

  getTurnOrder(): Unit[] {
    const playerUnits = this.playerUnits.filter(u => !u.isDead());
    const enemyUnits = this.enemyUnits.filter(u => !u.isDead());
    
    if (this.isPlayerTurn()) {
      return playerUnits;
    } else {
      return enemyUnits;
    }
  }

  getRemainingUnits(): { player: Unit[]; enemy: Unit[] } {
    return {
      player: this.playerUnits.filter(u => !u.isDead()),
      enemy: this.enemyUnits.filter(u => !u.isDead())
    };
  }
}

export interface Unit {
  id: string;
  x: number;
  y: number;
  isPlayer: boolean;
  isDead(): boolean;
  canMoveTo(x: number, y: number): boolean;
  canAttack(target: Unit): boolean;
}


================================================
FILE: src/entities/Unit.ts
================================================
import { Element } from '../core/GameConfig';

export interface UnitStats {
  hp: number;
  maxHp: number;
  attack: number;
  defense: number;
  moveRange: number;
  attackRange: number;
  element: Element;
}

export interface ClaimRate {
  base: number; // åŸºç¡€å æ®ç‡ (0-100)
  modified: number; // å®é™…å æ®ç‡ (è€ƒè™‘çŠ¶æ€æ•ˆæœ)
}

export class Unit {
  public stats: UnitStats;
  public x: number;
  public y: number;
  public isSelected: boolean = false;
  public isPlayer: boolean;
  public hasActed: boolean = false;
  public hasMovedThisTurn: boolean = false;

  public claimRate: ClaimRate;
  public statusEffects: Set<string> = new Set();

  constructor(
    public id: string,
    public type: 'slime' | 'enemy',
    stats: Partial<UnitStats>,
    x: number,
    y: number,
    isPlayer: boolean = false,
    claimRate: number = 100
  ) {
    this.x = x;
    this.y = y;
    this.isPlayer = isPlayer;
    
    this.stats = {
      hp: stats.hp || 10,
      maxHp: stats.maxHp || 10,
      attack: stats.attack || 5,
      defense: stats.defense || 2,
      moveRange: stats.moveRange || 2,
      attackRange: stats.attackRange || 1,
      element: stats.element || 'water'
    };

    this.claimRate = {
      base: claimRate,
      modified: claimRate
    };
  }

  canMoveTo(x: number, y: number): boolean {
    const distance = Math.abs(x - this.x) + Math.abs(y - this.y);
    return distance <= this.stats.moveRange;
  }

  canAttack(target: Unit): boolean {
    const distance = Math.abs(target.x - this.x) + Math.abs(target.y - this.y);
    return distance <= this.stats.attackRange && this.isPlayer !== target.isPlayer;
  }

  canClaim(target: Unit): boolean {
    const distance = Math.abs(target.x - this.x) + Math.abs(target.y - this.y);
    return distance <= 1 && 
           this.type === 'slime' && 
           this.isPlayer && 
           !target.isPlayer && 
           target.type === 'enemy';
  }

  getClaimSuccessRate(target: Unit): number {
    if (!this.canClaim(target)) return 0;
    
    let rate = target.claimRate.modified;
    
    // è€ƒè™‘çŠ¶æ€æ•ˆæœå¯¹å æ®ç‡çš„å½±å“
    if (target.statusEffects.has('melted')) {
      rate = 100; // èåŒ–çŠ¶æ€ä¸‹100%å¯å æ®
    } else if (target.statusEffects.has('sticky')) {
      rate = Math.max(rate, 1); // ç²˜æ€§çŠ¶æ€ä¸‹è‡³å°‘1%
    }
    
    return Math.min(100, Math.max(0, rate));
  }

  attemptClaim(target: Unit): boolean {
    const successRate = this.getClaimSuccessRate(target);
    return Math.random() * 100 < successRate;
  }

  addStatusEffect(effect: string): void {
    this.statusEffects.add(effect);
  }

  removeStatusEffect(effect: string): void {
    this.statusEffects.delete(effect);
  }

  hasStatusEffect(effect: string): boolean {
    return this.statusEffects.has(effect);
  }

  takeDamage(damage: number): number {
    const actualDamage = Math.max(1, damage - this.stats.defense);
    this.stats.hp = Math.max(0, this.stats.hp - actualDamage);
    return actualDamage;
  }

  isDead(): boolean {
    return this.stats.hp <= 0;
  }

  getColor(): number {
    const colors = {
      fire: 0xe74c3c,
      water: 0x3498db,
      earth: 0x95a5a6,
      wind: 0x2ecc71,
      light: 0xf1c40f,
      dark: 0x9b59b6
    };
    return colors[this.stats.element];
  }
}


================================================
FILE: src/scenes/GameScene.ts
================================================
import * as Phaser from 'phaser';
import { MapSystem } from '../systems/MapSystem';
import { Unit } from '../entities/Unit';
import { GAME_CONFIG } from '../core/GameConfig';
import { TurnManager, TurnPhase } from '../core/TurnManager';

enum PlayerInputState {
  IDLE,
  UNIT_SELECTED,
  TARGETING_MOVE,
  TARGETING_ATTACK,
  TARGETING_CLAIM,
}

export class GameScene extends Phaser.Scene {
  private mapSystem!: MapSystem;
  private units: Unit[] = [];
  private playerUnits: Unit[] = [];
  private enemyUnits: Unit[] = [];
  private turnManager!: TurnManager;
  
  private selectedUnit: Unit | null = null;
  private unitObjects: Map<string, Phaser.GameObjects.Container> = new Map();
  
  private turnText!: Phaser.GameObjects.Text;
  private actionMenu!: Phaser.GameObjects.Container;

  private playerInputState: PlayerInputState = PlayerInputState.IDLE;

  constructor() {
    super({ key: 'GameScene' });
  }

  create(): void {
    this.mapSystem = new MapSystem(this);
    this.createInitialUnits();
    this.turnManager = new TurnManager(this.playerUnits, this.enemyUnits);
    this.setupInput();
    this.createUI();
    this.createActionMenu();
    this.updateTurnDisplay();
  }

  private setupInput(): void {
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (this.turnManager.getCurrentPhase() !== TurnPhase.PLAYER_TURN) return;
      const { x, y } = this.mapSystem.getGridPosition(pointer.x, pointer.y);
      this.handleTileClick(x, y);
    });
  }

  private createInitialUnits(): void {
    const slime1 = new Unit('slime1', 'slime', { hp: 15, maxHp: 15, attack: 6, defense: 3, moveRange: 4, attackRange: 1, element: 'water' }, 2, 5, true);
    const slime2 = new Unit('slime2', 'slime', { hp: 12, maxHp: 12, attack: 8, defense: 2, moveRange: 3, attackRange: 1, element: 'fire' }, 3, 6, true);
    this.addUnit(slime1);
    this.addUnit(slime2);

    const enemy1 = new Unit('enemy1', 'enemy', { hp: 20, maxHp: 20, attack: 10, defense: 4, moveRange: 3, attackRange: 1, element: 'earth' }, 15, 8, false, 100);
    const enemy2 = new Unit('enemy2', 'enemy', { hp: 18, maxHp: 18, attack: 9, defense: 3, moveRange: 3, attackRange: 1, element: 'wind' }, 16, 7, false, 20);
    this.addUnit(enemy1);
    this.addUnit(enemy2);
  }

  private addUnit(unit: Unit): void {
    this.units.push(unit);
    if (unit.isPlayer) {
      this.playerUnits.push(unit);
    } else {
      this.enemyUnits.push(unit);
    }
    this.mapSystem.setTileOccupied(unit.x, unit.y, true);
    this.createUnitObjects(unit);
  }

  private createUnitObjects(unit: Unit): void {
    const { x, y } = this.mapSystem.getScreenPosition(unit.x, unit.y);
    
    const sprite = this.add.graphics();
    const healthText = this.add.text(0, GAME_CONFIG.GRID_SIZE / 2, unit.stats.hp.toString(), {
      fontSize: '12px', color: '#ffffff', backgroundColor: 'rgba(0,0,0,0.5)', padding: { x: 2, y: 1 }
    }).setOrigin(0.5, 0);

    const container = this.add.container(x, y, [sprite, healthText]);
    this.unitObjects.set(unit.id, container);
    
    this.updateUnitSprite(unit);
  }

  private handleTileClick(x: number, y: number): void {
    const unitOnTile = this.getUnitAt(x, y);

    switch (this.playerInputState) {
      case PlayerInputState.IDLE:
        if (unitOnTile && unitOnTile.isPlayer && !unitOnTile.hasActed) {
          this.selectUnit(unitOnTile);
        }
        break;

      case PlayerInputState.UNIT_SELECTED:
         if (unitOnTile && unitOnTile === this.selectedUnit) {
            this.playerInputState = PlayerInputState.TARGETING_MOVE;
            this.showMovementRange(this.selectedUnit!);
            this.hideActionMenu();
         } else if (unitOnTile && unitOnTile.isPlayer && !unitOnTile.hasActed) {
          this.selectUnit(unitOnTile);
        } else {
          this.deselectUnit();
        }
        break;

      case PlayerInputState.TARGETING_MOVE:
        if (this.selectedUnit && this.selectedUnit.canMoveTo(x, y) && !unitOnTile) {
          this.moveUnit(this.selectedUnit, x, y);
          this.postMoveUpdate();
        } else {
          this.returnToUnitSelectedState();
        }
        break;

      case PlayerInputState.TARGETING_ATTACK:
        if (this.selectedUnit && unitOnTile && this.selectedUnit.canAttack(unitOnTile)) {
          this.attackUnit(this.selectedUnit, unitOnTile);
          this.completePlayerAction(this.selectedUnit);
        } else {
          this.returnToUnitSelectedState();
        }
        break;
        
      case PlayerInputState.TARGETING_CLAIM:
        if (this.selectedUnit && unitOnTile && this.selectedUnit.canClaim(unitOnTile)) {
          this.claimUnit(this.selectedUnit, unitOnTile);
        } else {
          this.returnToUnitSelectedState();
        }
        break;
    }
  }

  private selectUnit(unit: Unit): void {
    this.deselectUnit();
    this.selectedUnit = unit;
    this.returnToUnitSelectedState();
  }
  
  private returnToUnitSelectedState(): void {
    if (!this.selectedUnit) return;
    this.playerInputState = PlayerInputState.UNIT_SELECTED;
    this.mapSystem.clearAllHighlights();
    this.mapSystem.highlightTile(this.selectedUnit.x, this.selectedUnit.y, GAME_CONFIG.COLORS.SELECTED);
    this.showActionMenu(this.selectedUnit);
  }

  private postMoveUpdate(): void {
    if (!this.selectedUnit) return;
    this.selectedUnit.hasMovedThisTurn = true;
    this.returnToUnitSelectedState();
  }

  private deselectUnit(): void {
    this.selectedUnit = null;
    this.playerInputState = PlayerInputState.IDLE;
    this.mapSystem.clearAllHighlights();
    this.hideActionMenu();
  }

  private showMovementRange(unit: Unit): void {
    this.mapSystem.clearAllHighlights();
    this.mapSystem.highlightTile(unit.x, unit.y, GAME_CONFIG.COLORS.SELECTED);
    
    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
      for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
        if (unit.canMoveTo(x, y) && !this.mapSystem.isTileOccupied(x, y)) {
          this.mapSystem.highlightTile(x, y, GAME_CONFIG.COLORS.MOVE_RANGE);
        }
      }
    }
  }

  private showAttackRange(unit: Unit): void {
    this.mapSystem.clearAllHighlights();
    this.mapSystem.highlightTile(unit.x, unit.y, GAME_CONFIG.COLORS.SELECTED);

    this.enemyUnits.forEach(enemy => {
      if (!enemy.isDead() && unit.canAttack(enemy)) {
        this.mapSystem.highlightTile(enemy.x, enemy.y, GAME_CONFIG.COLORS.ATTACK_RANGE);
      }
    });
  }
  
  private showClaimRange(unit: Unit): void {
    this.mapSystem.clearAllHighlights();
    this.mapSystem.highlightTile(unit.x, unit.y, GAME_CONFIG.COLORS.SELECTED);

    this.enemyUnits.forEach(enemy => {
      if (!enemy.isDead() && unit.canClaim(enemy)) {
        this.mapSystem.highlightTile(enemy.x, enemy.y, GAME_CONFIG.COLORS.CLAIM_RANGE);
      }
    });
  }

  private moveUnit(unit: Unit, x: number, y: number): void {
    this.mapSystem.setTileOccupied(unit.x, unit.y, false);
    unit.x = x;
    unit.y = y;
    this.mapSystem.setTileOccupied(x, y, true);
    this.updateUnitPosition(unit);
  }

  private attackUnit(attacker: Unit, target: Unit): void {
    const damage = Math.max(1, attacker.stats.attack - target.stats.defense);
    target.takeDamage(damage);
    console.log(`${attacker.id} attacks ${target.id} for ${damage} damage!`);
    
    if (target.isDead()) {
      console.log(`${target.id} has been defeated!`);
      this.removeUnit(target);
    } else {
      this.updateUnitSprite(target);
    }
  }

  private claimUnit(slime: Unit, target: Unit): void {
    const success = slime.attemptClaim(target);
    console.log(`${slime.id} attempts to claim ${target.id} - ${success ? 'SUCCESS' : 'FAILED'}`);
    
    if (success) {
      this.removeUnit(slime);
      target.isPlayer = true;
      this.enemyUnits = this.enemyUnits.filter(u => u.id !== target.id);
      this.playerUnits.push(target);
      this.updateUnitSprite(target);
    }
    
    this.completePlayerAction(slime);
  }

  private removeUnit(unit: Unit): void {
    this.mapSystem.setTileOccupied(unit.x, unit.y, false);
    
    this.unitObjects.get(unit.id)?.destroy();
    this.unitObjects.delete(unit.id);
    
    this.units = this.units.filter(u => u.id !== unit.id);
    if (unit.isPlayer) {
      this.playerUnits = this.playerUnits.filter(u => u.id !== unit.id);
    } else {
      this.enemyUnits = this.enemyUnits.filter(u => u.id !== unit.id);
    }
  }

  private updateUnitPosition(unit: Unit): void {
    const { x, y } = this.mapSystem.getScreenPosition(unit.x, unit.y);
    this.unitObjects.get(unit.id)?.setPosition(x, y);
  }

  private updateUnitSprite(unit: Unit): void {
    const container = this.unitObjects.get(unit.id);
    if (!container) return;

    const sprite = container.getAt(0) as Phaser.GameObjects.Graphics;
    const healthText = container.getAt(1) as Phaser.GameObjects.Text;

    sprite.clear();
    const color = unit.isPlayer ? unit.getColor() : 0x8e44ad;
    const alpha = unit.hasActed ? 0.5 : 1.0;
    sprite.fillStyle(color, alpha);
    sprite.fillCircle(0, 0, GAME_CONFIG.GRID_SIZE / 3);
    sprite.lineStyle(2, 0xffffff, alpha);
    sprite.strokeCircle(0, 0, GAME_CONFIG.GRID_SIZE / 3);

    healthText.setText(unit.stats.hp.toString());
    
    this.updateUnitPosition(unit);
  }

  private createUI(): void {
    this.turnText = this.add.text(10, 10, '', { fontSize: '16px', color: '#ffffff', backgroundColor: '#000000', padding: { x: 10, y: 5 } });
  }

  private createActionMenu(): void {
    const menuStyle = { fontSize: '14px', color: '#000000', backgroundColor: '#ecf0f1', padding: { x: 8, y: 4 }, width: 60, align: 'center' };
    
    const moveButton = this.add.text(0, 0, 'Move', menuStyle).setInteractive().on('pointerdown', (event: Phaser.Input.Pointer) => {
      event.stopPropagation();
      if (this.selectedUnit) {
        this.playerInputState = PlayerInputState.TARGETING_MOVE;
        this.showMovementRange(this.selectedUnit);
        this.hideActionMenu();
      }
    });

    const attackButton = this.add.text(0, 30, 'Attack', menuStyle).setInteractive().on('pointerdown', (event: Phaser.Input.Pointer) => {
      event.stopPropagation();
      if (this.selectedUnit) {
        this.playerInputState = PlayerInputState.TARGETING_ATTACK;
        this.showAttackRange(this.selectedUnit);
        this.hideActionMenu();
      }
    });

    const claimButton = this.add.text(0, 60, 'Claim', menuStyle).setInteractive().on('pointerdown', (event: Phaser.Input.Pointer) => {
      event.stopPropagation();
      if (this.selectedUnit && this.selectedUnit.type === 'slime') {
        this.playerInputState = PlayerInputState.TARGETING_CLAIM;
        this.showClaimRange(this.selectedUnit);
        this.hideActionMenu();
      }
    });

    const waitButton = this.add.text(0, 90, 'Wait', menuStyle).setInteractive().on('pointerdown', (event: Phaser.Input.Pointer) => {
      event.stopPropagation();
      if (this.selectedUnit) {
        this.completePlayerAction(this.selectedUnit);
      }
    });

    this.actionMenu = this.add.container(0, 0, [moveButton, attackButton, claimButton, waitButton]);
    this.actionMenu.setDepth(10);
    this.actionMenu.setVisible(false);
  }

  private showActionMenu(unit: Unit): void {
    const { x, y } = this.mapSystem.getScreenPosition(unit.x, unit.y);
    this.actionMenu.setPosition(x + 20, y - 20);
    
    const moveButton = this.actionMenu.getAt(0) as Phaser.GameObjects.Text;
    moveButton.setInteractive(!unit.hasMovedThisTurn);
    moveButton.setAlpha(unit.hasMovedThisTurn ? 0.5 : 1.0);

    const claimButton = this.actionMenu.getAt(2) as Phaser.GameObjects.Text;
    claimButton.setVisible(unit.type === 'slime');
    
    this.actionMenu.setVisible(true);
  }

  private hideActionMenu(): void {
    this.actionMenu.setVisible(false);
  }

  private completePlayerAction(unit: Unit): void {
    unit.hasActed = true;
    this.updateUnitSprite(unit);
    this.deselectUnit();
    this.checkPlayerTurnEnd();
  }

  private checkPlayerTurnEnd(): void {
    const allPlayerUnitsActed = this.playerUnits.every(p => p.hasActed || p.isDead());
    if (allPlayerUnitsActed) {
      this.time.delayedCall(500, () => this.endPlayerTurn());
    }
  }

  private endPlayerTurn(): void {
    if (this.turnManager.getCurrentPhase() !== TurnPhase.PLAYER_TURN) return;
    this.deselectUnit();
    this.turnManager.endPlayerTurn();
    this.updateTurnDisplay();
    this.time.delayedCall(500, () => this.processEnemyTurn());
  }

  private processEnemyTurn(): void {
    const enemiesCanAct = this.enemyUnits.filter(e => !e.isDead() && !e.hasActed);
    let i = 0;

    const processNextEnemy = () => {
      if (i >= enemiesCanAct.length) {
        this.time.delayedCall(500, () => this.endEnemyTurn());
        return;
      }

      const enemy = enemiesCanAct[i];
      let target = this.findBestTargetFor(enemy);

      if (!target) {
        this.moveEnemyTowardsPlayer(enemy);
        target = this.findBestTargetFor(enemy);
      }
      
      if (target) {
        this.attackUnit(enemy, target);
      }
      
      enemy.hasActed = true;
      i++;
      this.time.delayedCall(400, processNextEnemy);
    };
    
    processNextEnemy();
  }
  
  private moveEnemyTowardsPlayer(enemy: Unit): void {
    const closestPlayer = this.findClosestPlayerFor(enemy);
    if (!closestPlayer) return;

    let bestMove: {x: number, y: number} | null = null;
    let minDistance = Math.abs(enemy.x - closestPlayer.x) + Math.abs(enemy.y - closestPlayer.y);

    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
      for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
        if (enemy.canMoveTo(x, y) && !this.mapSystem.isTileOccupied(x, y)) {
          const distance = Math.abs(x - closestPlayer.x) + Math.abs(y - closestPlayer.y);
          if (distance < minDistance) {
            minDistance = distance;
            bestMove = { x, y };
          }
        }
      }
    }

    if (bestMove) {
      this.moveUnit(enemy, bestMove.x, bestMove.y);
    }
  }

  private findClosestPlayerFor(enemy: Unit): Unit | null {
    const alivePlayers = this.playerUnits.filter(p => !p.isDead());
    if (alivePlayers.length === 0) return null;

    return alivePlayers.reduce((closest, player) => {
      const closestDist = Math.abs(closest.x - enemy.x) + Math.abs(closest.y - enemy.y);
      const playerDist = Math.abs(player.x - enemy.x) + Math.abs(player.y - enemy.y);
      return playerDist < closestDist ? player : closest;
    });
  }

  private findBestTargetFor(enemy: Unit): Unit | null {
    const possibleTargets = this.playerUnits.filter(p => !p.isDead() && enemy.canAttack(p));
    if (possibleTargets.length === 0) return null;
    
    return possibleTargets.reduce((best, target) => target.stats.hp < best.stats.hp ? target : best);
  }

  private endEnemyTurn(): void {
    this.turnManager.endEnemyTurn();
    this.updateTurnDisplay();
    
    this.units.forEach(u => {
      if (!u.isDead()) {
        u.hasActed = false;
        u.hasMovedThisTurn = false;
        this.updateUnitSprite(u);
      }
    });
    
    const gameOver = this.turnManager.checkGameOver();
    if (gameOver.isOver) {
      this.showGameOver(gameOver.winner);
    }
  }

  private updateTurnDisplay(): void {
    const phase = this.turnManager.getCurrentPhase();
    this.turnText.setText(phase === TurnPhase.PLAYER_TURN ? 'Player Turn' : 'Enemy Turn');
  }

  private showGameOver(winner: 'player' | 'enemy' | null): void {
    const winText = winner === 'player' ? 'You Win!' : 'Game Over';
    this.add.text(this.cameras.main.centerX, this.cameras.main.centerY, winText, {
      fontSize: '48px', color: '#ffffff', backgroundColor: 'rgba(0,0,0,0.7)'
    }).setOrigin(0.5).setDepth(20);
    this.input.enabled = false;
  }

  private getUnitAt(x: number, y: number): Unit | null {
    return this.units.find(unit => !unit.isDead() && unit.x === x && unit.y === y) || null;
  }
}


================================================
FILE: src/systems/MapSystem.ts
================================================
import * as Phaser from 'phaser';
import { GAME_CONFIG } from '../core/GameConfig';

export interface Tile {
  x: number;
  y: number;
  occupied: boolean;
  terrain: 'grass' | 'water' | 'mountain' | 'forest';
  highlight: Phaser.GameObjects.Graphics | null;
}

export class MapSystem {
  private tiles: Tile[][] = [];
  private graphics: Phaser.GameObjects.Graphics;

  constructor(private scene: Phaser.Scene) {
    this.graphics = scene.add.graphics();
    this.initializeMap();
    this.drawGrid();
  }

  private initializeMap(): void {
    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
      this.tiles[y] = [];
      for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
        this.tiles[y][x] = {
          x,
          y,
          occupied: false,
          terrain: 'grass',
          highlight: null
        };
      }
    }
  }

  private drawGrid(): void {
    this.graphics.clear();
    
    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
      for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
        const pixelX = x * GAME_CONFIG.GRID_SIZE;
        const pixelY = y * GAME_CONFIG.GRID_SIZE;
        
        this.graphics.lineStyle(1, GAME_CONFIG.COLORS.GRID_BORDER, 0.5);
        this.graphics.strokeRect(pixelX, pixelY, GAME_CONFIG.GRID_SIZE, GAME_CONFIG.GRID_SIZE);
        
        const tile = this.tiles[y][x];
        this.drawTerrain(pixelX, pixelY, tile.terrain);
      }
    }
  }

  private drawTerrain(x: number, y: number, terrain: string): void {
    const colors = {
      grass: 0x27ae60,
      water: 0x2980b9,
      mountain: 0x7f8c8d,
      forest: 0x229954
    };

    this.graphics.fillStyle(colors[terrain as keyof typeof colors], 0.3);
    this.graphics.fillRect(x + 1, y + 1, GAME_CONFIG.GRID_SIZE - 2, GAME_CONFIG.GRID_SIZE - 2);
  }

  getTile(x: number, y: number): Tile | null {
    if (x < 0 || x >= GAME_CONFIG.MAP_WIDTH || y < 0 || y >= GAME_CONFIG.MAP_HEIGHT) {
      return null;
    }
    return this.tiles[y][x];
  }

  setTileOccupied(x: number, y: number, occupied: boolean): void {
    const tile = this.getTile(x, y);
    if (tile) {
      tile.occupied = occupied;
    }
  }

  isTileOccupied(x: number, y: number): boolean {
    const tile = this.getTile(x, y);
    return tile ? tile.occupied : true;
  }

  highlightTile(x: number, y: number, color: number, alpha: number = 0.5): void {
    const tile = this.getTile(x, y);
    if (!tile) return;

    this.clearHighlight(x, y);

    const pixelX = x * GAME_CONFIG.GRID_SIZE;
    const pixelY = y * GAME_CONFIG.GRID_SIZE;

    tile.highlight = this.scene.add.graphics();
    tile.highlight.fillStyle(color, alpha);
    tile.highlight.fillRect(pixelX + 2, pixelY + 2, GAME_CONFIG.GRID_SIZE - 4, GAME_CONFIG.GRID_SIZE - 4);
  }

  clearHighlight(x: number, y: number): void {
    const tile = this.getTile(x, y);
    if (tile?.highlight) {
      tile.highlight.destroy();
      tile.highlight = null;
    }
  }

  clearAllHighlights(): void {
    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
      for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
        this.clearHighlight(x, y);
      }
    }
  }

  getGridPosition(screenX: number, screenY: number): { x: number; y: number } {
    return {
      x: Math.floor(screenX / GAME_CONFIG.GRID_SIZE),
      y: Math.floor(screenY / GAME_CONFIG.GRID_SIZE)
    };
  }

  getScreenPosition(gridX: number, gridY: number): { x: number; y: number } {
    return {
      x: gridX * GAME_CONFIG.GRID_SIZE + GAME_CONFIG.GRID_SIZE / 2,
      y: gridY * GAME_CONFIG.GRID_SIZE + GAME_CONFIG.GRID_SIZE / 2
    };
  }
}

